
EJERCICIO NOSQL MONGODB

> use sample_restaurants

1. ¿Cuántas colecciones tiene la base de datos?
> show collections


2. ¿Cuántos documentos en cada colección? ¿Cuánto pesa cada colección?
// Cantidad Documentos
> db.restaurants.countDocuments()
> db.neighborhoods.countDocuments()

// Peso de la collecion
> db.restaurants.totalSize()
> db.neighborhoods.totalSize()


3. ¿Cuántos índices en cada colección? ¿Cuánto espacio ocupan los índices de cada
colección?
// indices en cada coleccion
> db.restaurants.getIndexes()
> db.neighborhoods.getIndexes()

// Espacio de los indices
> db.restaurants.totalIndexSize()
> db.neighborhoods.totalIndexSize()


4. Traer un documento de ejemplo de cada colección. db.collection.find(...).pretty() nos da
un formato más legible.
> db.restaurants.findOne()
> db.neighborhoods.findOne()


------------------------------------------------------
// SEGUNDA PARTE EN RESTAURANTS

1. Devolver restaurant_id, name, borough y cuisine pero excluyendo _id para un documento (el primero).
> db.restaurants.findOne({}, {name:1, borough:1, cuisine:1, _id:0})


2. Devolver restaurant_id, name, borough y cuisine para los primeros 3 restaurantes que contengan 'Bake' en alguna parte de su nombre.
> db.restaurants.find({name:/Bake/}, {name:1, borough:1, cuisine:1, _id:1}).limit(3)


3. Contar los restaurantes de comida (cuisine) china (Chinese) o tailandesa (Thai) del barrio (borough) Bronx.
> db.restaurants.find({borough:'Bronx', cuisine:{$in:["Thai", "Chinese"]}}, {name:1, borough:1, cuisine:1, _id:0}).count()


4. Traer 3 restaurantes que hayan recibido al menos una calificación de grade 'A' con score mayor a 50. Una misma calificación debe cumplir con ambas condiciones simultáneamente; investigar el operador elemMatch.
> db.restaurants.find({grades: {$elemMatch:{grade:"A", score:{$gt:50}} }}, {name:1, grades:1, _id:0}).limit(3)


5. ¿A cuántos documentos les faltan las coordenadas geográficas? En otras palabras, revisar si el tamaño de address.coord es 0 y contar.
> db.restaurants.find({"address.coord":{$size:0}}, {name:1, address:1, _id:0}).count()



6. Devolver name, borough, cuisine y grades para los primeros 3 restaurantes; de cada documento solo la última calificación. Ver el operador slice.
> db.restaurants.find({}, {name:1, borough:1, cuisine:1, grades:{$slice:-1}, _id:0}).limit(3)

-----------------------------------------------------
// DESAFIANTES

1. ¿Cuál es top 3 de tipos de cocina (cuisine) que podemos encontrar entre los datos? Googlear "mongodb group by field, count it and sort it". 

> db.restaurants.aggregate([
  {$group: {_id:"$cuisine", count:{ $sum: 1 }} },
  {$sort: {count: -1}},
  {$limit : 3}
  ]);



2. ¿Cuáles son los barrios más desarrollados gastronómicamente? Calcular el promedio ($avg) de puntaje (grades.score) por barrio; considerando restaurantes que tengan más de tres reseñas; ordenar barrios con mejor puntaje arriba.

> db.restaurants.aggregate([
	{$match: {grades:{$size:3} },
	{$unwind : "$grades"},
  	{$group: {_id:"$borough", avgScore:{ $avg: "$grades.score" }}},
  	{$sort: {avgScore: -1}}
  	]);



